"""
Code Review Constitution Validator

Validates compliance with the ZeroUI 2.0 Code Review Constitution.
Covers PR requirements, review process, testing, and governance.
"""

import re
from typing import List, Dict, Any, Optional
from pathlib import Path
from..models import Violation, Severity


class CodeReviewValidator:
    """Validates code review standards and PR requirements."""

    def __init__(self):
        self.rules = {
            'R001': self._validate_loc_limit,
            'R002': self._validate_pr_size,
            'R003': self._validate_codeowners_approval,
            'R004': self._validate_review_sla,
            'R005': self._validate_why_first,
            'R006': self._validate_small_coherent_diffs,
            'R007': self._validate_tests_prove_behavior,
            'R009': self._validate_security_privacy_first,
            'R010': self._validate_reversible_changes,
            'R011': self._validate_change_management,
            'R012': self._validate_compliance_requirements,
            'R076': self._validate_change_control,
            'R077': self._validate_testing_requirements,
            'R081': self._validate_dependency_policy
        }

    def validate(self, file_path: str, content: str) -> List[Violation]:
        """Validate code review compliance for a file."""
        violations = []

        # Check for LOC limit violations
        violations.extend(self._validate_loc_limit(content, file_path))

        # Check for security and privacy violations
        violations.extend(self._validate_security_privacy_first(content, file_path))

        # Check for testing requirements
        violations.extend(self._validate_tests_prove_behavior(content, file_path))

        # Check for dependency policy compliance
        violations.extend(self._validate_dependency_policy(content, file_path))

        # Check for change management
        violations.extend(self._validate_change_management(content, file_path))

        return violations

    def _validate_loc_limit(self, content: str, file_path: str) -> List[Violation]:
        """Validate LOC limit for AI code generation tasks."""
        violations = []
        lines = content.split('\n')
        non_empty_lines = [line for line in lines if line.strip()]

        # Check if this is an AI-generated file (look for AI markers)
        is_ai_generated = any(marker in content.lower() for marker in [
            'ai-generated', 'generated by', 'auto-generated', 'gpt', 'claude', 'copilot'
        ])

        if is_ai_generated and len(non_empty_lines) > 50:
            # Check for LOC_OVERRIDE
            if 'LOC_OVERRIDE' not in content:
                violations.append(Violation(
                    file_path=file_path,
                    line_number=1,
                    message=f'AI code-gen task limit ≤ 50 LOC (found {len(non_empty_lines)}), unless LOC_OVERRIDE specified',
                    severity=Severity.ERROR,
                    category='scope'
                ))

        return violations

    def _validate_pr_size(self, content: str, file_path: str) -> List[Violation]:
        """Validate PR size guidance."""
        violations = []

        # This would typically be checked at the PR level, not file level
        # But we can check for indicators of large changes
        lines = content.split('\n')
        if len(lines) > 300:
            violations.append(Violation(
                file_path=file_path,
                line_number=1,
                message='PR size ≤ 300 LOC changed (tests excluded), include Rollout Plan if larger',
                severity=Severity.WARNING,
                category='scope'
            ))

        return violations

    def _validate_codeowners_approval(self, content: str, file_path: str) -> List[Violation]:
        """Validate CODEOWNERS approval requirements."""
        violations = []

        # Check for sensitive areas that require CODEOWNERS approval
        sensitive_keywords = ['auth', 'policy', 'contracts', 'receipts', 'migrations']
        has_sensitive_content = any(keyword in content.lower() for keyword in sensitive_keywords)

        if has_sensitive_content:
            # Check for CODEOWNERS file
            codeowners_path = Path(file_path).parent / 'CODEOWNERS'
            if not codeowners_path.exists():
                violations.append(Violation(
                        rule_name='Sensitive areas require CODEOWNERS approval and may need two reviewers',
                        severity=Severity.ERROR,
                        message='Sensitive areas require CODEOWNERS approval and may need two reviewers',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='governance'

                    ))

        return violations

    def _validate_review_sla(self, content: str, file_path: str) -> List[Violation]:
        """Validate review SLA requirements."""
        violations = []

        # This is typically enforced at the PR level, not file level
        # But we can check for review-related comments
        if 'review' in content.lower() and 'urgent' in content.lower():
            violations.append(Violation(
                        rule_name='Reviews should start within 2 business days',
                        severity=Severity.WARNING,
                        message='Reviews should start within 2 business days',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='process'

                    ))

        return violations

    def _validate_why_first(self, content: str, file_path: str) -> List[Violation]:
        """Validate Why First principle."""
        violations = []

        # Check for PR description patterns
        if 'what' in content.lower() and 'why' not in content.lower():
            violations.append(Violation(
                file_path=file_path,
                line_number=1,
                message='PR must state What changed and Why we did it (problem, constraints, trade-offs)',
                severity=Severity.ERROR,
                category='process'
            ))

        return violations

    def _validate_small_coherent_diffs(self, content: str, file_path: str) -> List[Violation]:
        """Validate small coherent diffs principle."""
        violations = []

        # Check for feature flag usage for risky changes
        risky_keywords = ['database', 'migration', 'auth', 'security', 'payment']
        has_risky_changes = any(keyword in content.lower() for keyword in risky_keywords)

        if has_risky_changes and 'feature-flag' not in content.lower():
            violations.append(Violation(
                        rule_name='One intent per PR; feature-flags for risky changes',
                        severity=Severity.WARNING,
                        message='One intent per PR; feature-flags for risky changes',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='process'

                    ))

        return violations

    def _validate_tests_prove_behavior(self, content: str, file_path: str) -> List[Violation]:
        """Validate that tests prove behavior."""
        violations = []

        # Check if this is a source file without corresponding tests
        if self._is_source_file(file_path) and not self._has_corresponding_tests(file_path):
            violations.append(Violation(
                        rule_name='No code change without tests that fail before and pass after the change',
                        severity=Severity.ERROR,
                        message='No code change without tests that fail before and pass after the change',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='quality'

                    ))

        return violations

    def _validate_security_privacy_first(self, content: str, file_path: str) -> List[Violation]:
        """Validate security and privacy first principle."""
        violations = []

        # Check for hardcoded secrets
        secret_patterns = [
            r'(?i)(password|api_key|secret|token|private_key)\s*=\s*["\'][^"\']+["\']',
            r'(?i)(password|api_key|secret|token|private_key)\s*:\s*["\'][^"\']+["\']',
            r'(?i)(password|api_key|secret|token|private_key)\s*=\s*[^\\s]+',
        ]

        lines = content.split('\n')
        for line_num, line in enumerate(lines, 1):
            for pattern in secret_patterns:
                if re.search(pattern, line):
                    violations.append(Violation(
                        rule_name='No secrets/PII in code, comments, logs, tests, or fixtures',
                        severity=Severity.ERROR,
                        message='No secrets/PII in code, comments, logs, tests, or fixtures',
                        file_path=file_path,
                        line_number=line_num,
                        column_number=0,
                        code_snippet=line.strip(),
                        category='security'
                    ))

        # Check for PII patterns
        pii_patterns = [
            r'(?i)(ssn|social_security|credit_card|phone|email)\s*=\s*["\'][^"\']+["\']',
            r'(?i)(ssn|social_security|credit_card|phone|email)\s*:\s*["\'][^"\']+["\']',
        ]

        for line_num, line in enumerate(lines, 1):
            for pattern in pii_patterns:
                if re.search(pattern, line):
                    violations.append(Violation(
                        rule_name='No secrets/PII in code, comments, logs, tests, or fixtures',
                        severity=Severity.ERROR,
                        message='No secrets/PII in code, comments, logs, tests, or fixtures',
                        file_path=file_path,
                        line_number=line_num,
                        column_number=0,
                        code_snippet=line.strip(),
                        category='security'
                    ))

        return violations

    def _validate_reversible_changes(self, content: str, file_path: str) -> List[Violation]:
        """Validate reversible changes principle."""
        violations = []

        # Check for rollback/disable plans
        risky_keywords = ['database', 'migration', 'deployment', 'config']
        has_risky_changes = any(keyword in content.lower() for keyword in risky_keywords)

        if has_risky_changes:
            rollback_keywords = ['rollback', 'disable', 'revert', 'undo']
            has_rollback_plan = any(keyword in content.lower() for keyword in rollback_keywords)

            if not has_rollback_plan:
                violations.append(Violation(
                        rule_name='Include a rollback/disable plan for non-trivial changes',
                        severity=Severity.WARNING,
                        message='Include a rollback/disable plan for non-trivial changes',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='process'

                    ))

        return violations

    def _validate_change_management(self, content: str, file_path: str) -> List[Violation]:
        """Validate change management requirements."""
        violations = []

        # Check for change management indicators
        change_keywords = ['impact', 'migration', 'deployment', 'rollout']
        has_change_management = any(keyword in content.lower() for keyword in change_keywords)

        if not has_change_management and self._is_significant_change(content):
            violations.append(Violation(
                        rule_name='Include change management and impact assessment',
                        severity=Severity.WARNING,
                        message='Include change management and impact assessment',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='process'

                    ))

        return violations

    def _validate_compliance_requirements(self, content: str, file_path: str) -> List[Violation]:
        """Validate compliance requirements."""
        violations = []

        # Check for compliance indicators
        compliance_keywords = ['compliance', 'constitution', 'policy', 'standard']
        has_compliance = any(keyword in content.lower() for keyword in compliance_keywords)

        if not has_compliance and self._is_significant_change(content):
            violations.append(Violation(
                        rule_name='Ensure compliance with all applicable constitutions',
                        severity=Severity.ERROR,
                        message='Ensure compliance with all applicable constitutions',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='governance'

                    ))

        return violations

    def _validate_change_control(self, content: str, file_path: str) -> List[Violation]:
        """Validate change control process."""
        violations = []

        # Check for change control indicators
        change_control_keywords = ['change', 'control', 'process', 'approval']
        has_change_control = any(keyword in content.lower() for keyword in change_control_keywords)

        if not has_change_control and self._is_significant_change(content):
            violations.append(Violation(
                        rule_name='All changes must go through proper change control process',
                        severity=Severity.ERROR,
                        message='All changes must go through proper change control process',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='governance'

                    ))

        return violations

    def _validate_testing_requirements(self, content: str, file_path: str) -> List[Violation]:
        """Validate testing requirements."""
        violations = []

        # Check if this is a source file without corresponding tests
        if self._is_source_file(file_path) and not self._has_corresponding_tests(file_path):
            violations.append(Violation(
                        rule_name='All code changes must include appropriate tests',
                        severity=Severity.ERROR,
                        message='All code changes must include appropriate tests',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='quality'

                    ))

        return violations

    def _validate_dependency_policy(self, content: str, file_path: str) -> List[Violation]:
        """Validate dependency policy compliance."""
        violations = []

        # Check for new dependencies
        if self._is_dependency_file(file_path):
            # Check for license information
            if 'license' not in content.lower():
                violations.append(Violation(
                        rule_name='New dependencies must pass license allowlist and CVE threshold',
                        severity=Severity.ERROR,
                        message='New dependencies must pass license allowlist and CVE threshold',
                        file_path=file_path,
                        line_number=1,
                        column_number=0,
                        code_snippet="",
                        category='security'

                    ))

        return violations

    def _is_source_file(self, file_path: str) -> bool:
        """Check if file is a source code file."""
        source_extensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs']
        return any(file_path.endswith(ext) for ext in source_extensions)

    def _has_corresponding_tests(self, file_path: str) -> bool:
        """Check if source file has corresponding test files."""
        # This is a simplified check - in practice, you'd look for test files
        # in the same directory or test directories
        test_patterns = ['test_', '_test', '.test.', '.spec.']
        return any(pattern in file_path.lower() for pattern in test_patterns)

    def _is_dependency_file(self, file_path: str) -> bool:
        """Check if file is a dependency management file."""
        dependency_files = ['requirements.txt', 'package.json', 'Pipfile', 'poetry.lock', 'yarn.lock']
        return any(file_path.endswith(f) for f in dependency_files)

    def _is_significant_change(self, content: str) -> bool:
        """Check if content represents a significant change."""
        significant_indicators = [
            'database', 'migration', 'auth', 'security', 'payment', 'api',
            'config', 'deployment', 'infrastructure', 'monitoring'
        ]
        return any(indicator in content.lower() for indicator in significant_indicators)
